---
title: "Moving Averages"
output: html_document
---

Smoothing methods are a family of forecasting methods that average values over multiple periods in order to reduce the noise and uncover patterns in the data.  Moving averages are one such smoothing method.  Moving averages is a smoothing approach that averages values from a window of consecutive time periods, thereby generating a series of averages. The moving average approaches primarily differ based on the number of values averaged, how the average is computed, and how many times averaging is performed.

## tl;dr

1. [Replication Requirements](#replication): What you'll need to replicate the analysis in this tutorial
2. [Centered Moving Averages](#centered-moving-averages): Technique for calculating and displaying a simple moving average
3. [Moving Averages of Moving Averages](#moving-averages-of-moving-averages): Using the concept of simple moving averages to perform multi-step smoothing
4. [Weighted Moving Averages](#weighted-moving-averages): Smoothing by use of weights specifically chosen for their mathematical properties

<br>

## Replication Requirements {#replication}

There are four R packages outside of the base set of functions that will be used in the tutorial. The first two, `tidyverse` and `gridExtra`, work together to create customizable and easily interpretable visualizations of the data. The `lubridate` package allows the user to manipulate dates, and the `fpp2` package allows for many of the processes described to be executed with fewer commands.

```{r message=FALSE}
library(tidyverse)      # data manipulation and visualization
library(gridExtra)      # arrange figures and plots
library(lubridate)      # easily work with dates and times
library(fpp2)           # working with time series data
library(zoo)            # working with time series data
```

There are two built-in R data sets that will be used for examples in this tutorial. `elecsales` is a time series of annual electricity sales in South Australia from 1989 to 2008 in GigaWatt hours (GWh). The second data set, `AirPassengers` is a time series that tracks the number of international airline passengers (in thousands) by month from 1949 to 1960. Before performing analysis, we must do some preliminary cleaning of the two data sets.

```{r}
# first data set - convert from time series object to data frame
data("elecsales")
Elec <- data.frame(year = time(elecsales), sales = elecsales)

# second data set
data("AirPassengers")
Passengers <- data.frame(AirPassengers)
```

<br>

## Centered Moving Averages {#centered-moving-averages}

The most straightforward method is called a simple moving average. For this method, we choose a number of nearby points and average them to estimate the trend. When calculating a simple moving average, it is beneficial to use an odd number of points so that the calculation is symmetric. For example, to calculate a 5 point moving average, the formula is:

$$
\hat{y_t} = \dfrac{y_{t-2} + y_{t-1} + y_{t} + y_{t+1} + y_{t+2}}{5}
$$

where *t* is the time step that you are smoothing at and 5 is the number of points being used to calculate the average (which moving forward will be denoted as $k$). To compute moving averages on our data we can leverage the `rollmean` function from the `zoo` package.  Here, we focus on the personal savings rate (`psavert`) variable in the `economics` data frame.  Using `mutate` and `rollmean`, I compute the 3, 5, and 7 year moving average values and add this data back to the data frame.  Note that we need to explicitly state to fill any years that cannot be computed (due to lack of data) with NA.

```{r}
savings <- economics %>%
  select(date, srate = psavert) %>%
  mutate(srate_ma1 = rollmean(srate, k = 13, fill = NA),
         srate_ma2 = rollmean(srate, k = 25, fill = NA),
         srate_ma3 = rollmean(srate, k = 37, fill = NA),
         srate_ma5 = rollmean(srate, k = 61, fill = NA),
         srate_ma10 = rollmean(srate, k = 121, fill = NA))

savings
```

Now we can go ahead and plot these values and compare the actual data to the different moving average smoothers. 

```{r}
savings %>%
  gather(metric, value, srate:srate_ma10) %>%
  ggplot(aes(date, value, color = metric)) +
  geom_line()
```


You may notice that as the number of points used for the average increases, the curve becomes smoother and smoother. Choosing a value for $k$ is a balance between eliminating noise while still capturing the data's true structure. For this set, the 10 year moving average ($k = 121$) eliminates most of the pattern and is probably too much smoothing, while a 1 year moving average ($k = 13$) offers little more than just looking at the data itself.  We can see this by zooming into the 2000-2015 time range:

```{r}
savings %>%
  gather(metric, value, srate:srate_ma10) %>%
  ggplot(aes(date, value, color = metric)) +
  geom_line() +
  coord_cartesian(xlim = c(date("2000-01-01"), date("2015-04-01")), ylim = c(0, 11))
```

To understand how these different moving averages compare we can compute the [MSE and MAPE](ts_benchmarking#accuracy).  Both of these error rates will increase as you choose a larger *k* to average over; however, your or your leadership are indifferent between a 6-9% error rate then you may want to illustrate trends with a 3 year moving average rather than a 1 year moving average.

```{r}
savings %>%
  gather(metric, value, srate_ma1:srate_ma10) %>%
  group_by(metric) %>%
  summarise(MSE = mean((srate - value)^2, na.rm = TRUE),
            MAPE = mean(abs((srate - value)/srate), na.rm = TRUE))
```


### Using the fpp2 package

A simple moving average can also be plotted by using `autoplot()` contained in the `fpp2` package. This is helpful if your data is already in time series data object.  For example, if our savings rate data converted to a time series object as here...

```{r}
savings.ts <- economics %>%
  select(srate = psavert) %>%
  ts(start = c(1967, 7), frequency = 12)

head(savings.ts, 30)
```

...we can plot this data with `autoplot`.  Here, the data is plotted in line 1 of the following code, while the moving average (calculated using the `ma()` function) is plotted in the second layer.

```{r warning=FALSE, fig.align="center"}
autoplot(savings.ts, series = "Data") + 
  autolayer(ma(savings.ts, 13), series = "1 yr MA") +
  autolayer(ma(savings.ts, 61), series = "5 yr MA") +
  autolayer(ma(savings.ts, 121), series = "10 yr MA") +
  xlab("Date") + 
  ylab("Savings Rate")
```

## Trailing Moving Average for Forecasting

Centered moving averages are computed by averaging across data both in the past and future of a given time point. In that sense they cannot be used for forecasting because at the time of forecasting, the future is typically unknown. Hence, for purposes of forecasting, we use *trailing* moving averages, where the window of *k* periods is placed over the most recent available *k* values of the series.  For example, if we have data up to time period *t*, we can predict the value for *t+1* by averaging over *k* periods prior to *t+1*.  If we want to use the 5 most recent time periods to predict for *t+1* then our function looks like: 

$$
\hat{y}_{t+1} = \dfrac{y_{t-4} + y_{t-3} + y_{t-2} + y_{t-1} + y_{t}}{5}
$$

So, if we wanted to predict the next month's savings rate based on the previous year's average, we can use `rollmean` with the `align = "right"` argument to compute a trailing moving average.  We can see that if we wanted to predict what the savings rate would be for 2015-05-01 based on the the last 12 months, our prediction would be 5.06%.  This is now similar to using a [naive forecast](ts_benchmarking#naive) but with an averaged value rather than the last actual value.

```{r}
savings_tma <- economics %>%
  select(date, srate = psavert) %>%
  mutate(srate_tma = rollmean(srate, k = 12, fill = NA, align = "right"))

tail(savings_tma, 12)
```

We can visualize how the 12-month trailing moving average predicts future savings rates with the following plot.  It's easy to see that trailing moving averages have a delayed reaction to changes in patterns and trends.  

```{r}
savings_tma %>%
  gather(metric, value, -date) %>%
  ggplot(aes(date, value, color = metric)) +
  geom_line()
```


###Moving Averages of Moving Averages

The concept of simple moving averages can be extended to taking moving averages of moving averages. This technique is often employed with an even number of data points so that the final product is symmetric around each point. 

```{r}
# number of points to be included in average
m <- 4
k <- m/2

# moving average
Elec$ma4 <- rep(NA,nrow(Elec))
for (i in k:(nrow(Elec)-k)) {
  Elec$ma4[i] <- mean(Elec$GWh[(i-k+1):(i+k)])
}
```

An even-numbered moving average is unbalanced, and for our purposes, the unbalancing will be in favor of more recent observations. For example, to calculate a 4-MA, the equation is as follows:

$$
\hat{y_t} = \dfrac{y_{t-1} + y_{t} + y_{t+1} + y_{t+2}}{4}
$$

To make the moving average symmetric (and therefore more accurate), we then take a 2-MA of the 4-MA to create a **2 x 4-MA**. For the 2-MA step, we average the current and previous moving averages, thus resulting in an overall estimate of:

$$
\hat{y_t} = \dfrac{1}{8}y_{t-2} + \dfrac{1}{4}y_{t-1} + \dfrac{1}{4}y_{t} + \dfrac{1}{4}y_{t+1} + \dfrac{1}{8}y_{t+2}
$$

```{r message=FALSE, warning=FALSE, fig.align="center"}
# calculate moving average of moving average
Elec$ma2x4 <- rep(NA,nrow(Elec))
for (i in 2:nrow(Elec)) {
  Elec$ma2x4[i] <- mean(Elec$ma4[(i-1):i])
}

# plot results
ggplot() + geom_point(data = Elec, aes(x = year, y = GWh), color = "black") +
  geom_line(data = Elec, aes(x = year, y = GWh), color = "black") +
  geom_line(data = Elec, aes(x = year, y = ma2x4), color = "red", size = 1)
```

This 2 x 4-MA process produces the best fit yet. It massages out some of the noise while maintaining the overall trend of the data. Other combinations of moving averages are possible, such as 3 x 3-MA. To maintain symmetry, if your first moving average is an even number of points, the follow-up MA should also contain an even number. Likewise, if your first MA uses an odd number of points, the follow-up should use an odd number of points.

####Using the fpp2 package

The same ``autoplot()`` function used previously can be used for to calculate moving averages of moving averages. To perform a multi-step moving average, in the ``ma()`` function, you must choose an even number for ``order`` and set ``centre = TRUE``.

```{r warning=FALSE, fig.align="center"}
autoplot(elecsales, series = "Data") + 
  autolayer(ma(elecsales, order = 4, centre = TRUE), series = "2x4-MA") +
  xlab("Year") + ylab("GWh") +
  ggtitle("Annual electricity sales: South Australia") +
  scale_colour_manual(values = c("Data" = "grey50", "2x4-MA" = "red"),
                      breaks = c("Data","2x4-MA"))
```

This plot is identical to the **2 x 4-MA** plot constructed above, with a few differences in teh plot aesthetics.

###Weighted Moving Averages

A moving average of a moving average can be thought of as a symmetric MA that has different weights on each nearby observation. The most common use of a weighted moving average places weight $1/(2m)$ on the previous and following observations on the same season, while assigning weight $1/m$ on the other observations in the time period.

For example, the ``Passengers`` data contains an entry for every month in a 12 year span, so a time period would consist of 12 time units. A **2 x 12-MA** set-up is the preferred method for such data. The observation itself, as well as the 5 observations immediately before and after it, receives weight 1/12, while the data point for that month last year and that month the following year both receive weight 1/24. The weights are assigned and can be seen in the vector output shown below:

```{r}
# initialize 2 x 12-MA
Passengers$ma2x12 <- rep(NA,nrow(Passengers))

# calculate weights
weights <- c(1/24,rep(1/12,11),1/24)
weights
```

To calculate the 2 x 12-MA, which is a weighted MA with the weights specified previously, a for loop of matrix multiplication is utilized. The weighted MA is shown in the figure below.

```{r warning=FALSE, fig.align="center"}
# moving average value
m <- 12
k <- m/2

# calculate weighted MA
for (i in (k+1):(nrow(Passengers)-k-1)) {
  Passengers$ma2x12[i] <- weights %*% Passengers$nPass[(i-k):(i+k)]
}

# plot results
ggplot() + geom_point(data = Passengers, aes(x = Month, y = nPass), color = "black") +
  geom_line(data = Passengers, aes(x = Month, y = nPass), color = "black") +
  geom_line(data = Passengers, aes(x = Month, y = ma2x12), color = "red", size = 1)
```

This weighted average describes the trend in the data while eliminating the effect of seasonality on the pattern.

####Using the fpp2 package

The same process can be performed using the ``fpp2`` package. We set `centre = TRUE` and `order = 12` in the ``ma()`` function. Some additional plot aesthetics are adjusted as well.

```{r warning=FALSE, fig.align="center"}
autoplot(AirPassengers, series = "Data") + 
  autolayer(ma(AirPassengers, order = 12, centre = T), series = "2x12-MA") +
  xlab("Year") + ylab("GWh") +
  ggtitle("Annual electricity sales: South Australia") +
  scale_colour_manual(values = c("Data" = "grey50", "2x12-MA" = "red"),
                      breaks = c("Data","2x12-MA"))
```
